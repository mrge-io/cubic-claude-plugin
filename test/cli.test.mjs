import { describe, it, after } from "node:test"
import assert from "node:assert/strict"
import { execFile } from "node:child_process"
import { promisify } from "node:util"
import path from "node:path"
import { fileURLToPath } from "node:url"
import { rm } from "node:fs/promises"

const exec = promisify(execFile)
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const CLI = path.join(__dirname, "..", "dist", "index.js")
const TMP_BASE = path.join(__dirname, "..", ".test-output")

async function cleanup() {
  await rm(TMP_BASE, { recursive: true, force: true }).catch(() => {})
}

describe("install --json --skills-only", () => {
  after(cleanup)

  it("produces valid NDJSON on stdout for a single target", async () => {
    const outDir = path.join(TMP_BASE, "json-single")
    const { stdout } = await exec("node", [
      CLI,
      "install",
      "--json",
      "--skills-only",
      "--to",
      "claude",
      "-o",
      outDir,
    ])

    const lines = stdout.trim().split("\n")
    assert.ok(lines.length >= 4, `expected >=4 lines, got ${lines.length}`)

    const events = lines.map((l) => JSON.parse(l))

    assert.equal(events[0].type, "install_started")
    assert.equal(events[0].mode, "skills-only")
    assert.equal(events[0].target, "claude")
    assert.equal(events[0].version, 1)

    const started = events.find((e) => e.type === "target_started")
    assert.ok(started)
    assert.equal(started.agent, "claude")

    const result = events.find((e) => e.type === "target_result")
    assert.ok(result)
    assert.equal(result.agent, "claude")
    assert.equal(result.status, "ok")
    assert.equal(result.skills, 1)
    assert.equal(result.commands, 1)
    assert.equal(result.mcpServers, 0)

    const summary = events.find((e) => e.type === "install_summary")
    assert.ok(summary)
    assert.equal(summary.targetsTotal, 1)
    assert.equal(summary.targetsSucceeded, 1)
    assert.equal(summary.targetsFailed, 0)

    const last = events[events.length - 1]
    assert.equal(last.type, "install_completed")
    assert.equal(last.ok, true)

    const runIds = new Set(events.map((e) => e.runId))
    assert.equal(runIds.size, 1, "all events share a single runId")
  })

  it("produces valid NDJSON for all targets", async () => {
    const outDir = path.join(TMP_BASE, "json-all")
    const { stdout } = await exec("node", [
      CLI,
      "install",
      "--json",
      "--skills-only",
      "--to",
      "all",
      "-o",
      outDir,
    ])

    const events = stdout
      .trim()
      .split("\n")
      .map((l) => JSON.parse(l))

    assert.equal(events[0].type, "install_started")
    assert.equal(events[0].target, "all")

    const results = events.filter((e) => e.type === "target_result")
    assert.equal(results.length, 7, "one result per target")

    const summary = events.find((e) => e.type === "install_summary")
    assert.equal(summary.targetsTotal, 7)
    assert.equal(summary.skillsTotal, 7)
    assert.equal(summary.commandsTotal, 7)
  })

  it("each NDJSON line is valid JSON parseable by jq", async () => {
    const outDir = path.join(TMP_BASE, "json-jq")
    const { stdout } = await exec("node", [
      CLI,
      "install",
      "--json",
      "--skills-only",
      "--to",
      "claude",
      "-o",
      outDir,
    ])

    for (const line of stdout.trim().split("\n")) {
      assert.doesNotThrow(() => JSON.parse(line), `Invalid JSON line: ${line}`)
    }
  })

  it("stdout contains zero non-JSON lines", async () => {
    const outDir = path.join(TMP_BASE, "json-pure")
    const { stdout } = await exec("node", [
      CLI,
      "install",
      "--json",
      "--skills-only",
      "--to",
      "claude",
      "-o",
      outDir,
    ])

    for (const line of stdout.trim().split("\n")) {
      const parsed = JSON.parse(line)
      assert.ok(parsed.type, `line missing 'type' field: ${line}`)
      assert.equal(parsed.version, 1, "all events have version 1")
    }
  })
})

describe("install --json error paths", () => {
  it("unknown target emits install_failed with UNKNOWN_TARGET", async () => {
    try {
      await exec("node", [
        CLI,
        "install",
        "--json",
        "--to",
        "nonexistent",
      ])
      assert.fail("should have exited with non-zero code")
    } catch (err) {
      assert.ok(err.code !== 0, "exit code should be non-zero")
      const events = (err.stdout || "")
        .trim()
        .split("\n")
        .filter((l) => l)
        .map((l) => JSON.parse(l))
      const failed = events.find((e) => e.type === "install_failed")
      assert.ok(failed)
      assert.equal(failed.code, "UNKNOWN_TARGET")
      assert.equal(failed.retryable, false)
    }
  })
})

describe("install text mode (backward compatibility)", () => {
  after(cleanup)

  it("produces human-readable output with no JSON events", async () => {
    const outDir = path.join(TMP_BASE, "text-mode")
    const { stdout } = await exec("node", [
      CLI,
      "install",
      "--skills-only",
      "--to",
      "claude",
      "-o",
      outDir,
    ])

    assert.ok(stdout.includes("Installing cubic skills"), "has progress text")
    assert.ok(
      stdout.includes("claude: 1 skill, 1 command"),
      "has target summary",
    )
    assert.ok(stdout.includes("Done!"), "has completion message")

    for (const line of stdout.trim().split("\n")) {
      if (!line.trim()) continue
      let isJson = false
      try {
        const parsed = JSON.parse(line)
        if (parsed.type && parsed.version) isJson = true
      } catch {
        /* expected */
      }
      assert.ok(!isJson, `unexpected JSON event in text mode: ${line}`)
    }
  })
})
